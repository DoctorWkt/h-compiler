# h.eyp: Compiler for Warren's simple H language.
# All variables are global, char and int are the same.
# No recursion.
#
# (c) Warren Toomey, 2016. GPL3 license.
#
%token IDENTIFIER CONSTANT STRINGLITERAL
%token INC_OP DEC_OP LEFT_OP RIGHT_OP LE_OP GE_OP EQ_OP NE_OP 
%token CHAR INT VOID 
%token IF ELSE WHILE DO GOTO CONTINUE BREAK RETURN 
%left WEAK 
%right ELSE 
%start translation_unit 

%{
use Data::Dumper;
### GLOBALS ###
my ( $IN, $OUT );    	# Filehandles for input & output files
my $Basename;        	# Basename of both files
my @TokenQueue;      	# Stack of tokens not yet read
my $incomment;       	# Are we in a multi-line comment?
my $linenumber;      	# What line number we are on
my $Optimise=0;		# Are optimisations turned on?
my @Constlist;       	# List of constants in array initialisation
my %Global;          	# List of known global identifiers
my %Local;           	# List of known per-function identifiers
		     	# ->{fnname}->{id}
my %PPosn= (	     	# The parameter names at each position for each function
 'putchar' => [ 'c' ],
 'printn'  => [ 'n' ],
);

my $last_functionid="";	# Name of the last function that was created
my $calledfn="";	# Name of function being called, needed for arguments
my %Const;		# List of numeric constants used
my @FinalLine;       	# Array of references to arrays which contain all
		     	# the generated assembly code lines
my @Forstack;	     	# Stack of line arrayrefs of third expressions in FOR

my %Function=(       	# List of known function identifiers
    'printn' => 'proto',
    'getchar' => 'proto',
    'putchar' => 'proto',
    '.exit' => 'proto',
);
		     	# List of assembly code lines we have generated
		     	# but which have not yet been added to the final
		     	# set of lines in @FinalLine
my $Line=[ ['jms','main'],['sys','exit'] ];

		     	# List of keywords in the grammar
my %Keyword= (
  'break'    => 'BREAK',
  'char'     => 'CHAR',
  'continue' => 'CONTINUE',
  'do'       => 'DO',
  'else'     => 'ELSE',
  'for'      => 'FOR',
  'goto'     => 'GOTO',
  'if' 	     => 'IF',
  'int'      => 'INT',
  'return'   => 'RETURN',
  'switch'   => 'SWITCH',
  'void'     => 'VOID',
  'while'    => 'WHILE',
);
		     # List of known system calls to translate
my %Syscall= (
  'exit' => '.exit',
);

# Simple method to print error and die
sub Die
{
  my $err= shift;
  print(STDERR "$err on $Basename.h line $linenumber\n");
  exit(1);
}


# Declare a new global identifier id. If there are
# values print the label and values now.
sub new_globalid
{
  my ($id, $type, $valref)= @_;
  Die("$id global already declared") if (defined($Global{$id}));
  $Global{$id}=$type;
  return if (!defined($valref));

  # Arrays: also create a pointer to the array base
  if ($type eq "array") {
    push(@$Line, [ "$id: $id.base"]);
    push(@$Line, [ "$id.base:"]);
  } else {
    push(@$Line, [ "$id:"]);
  }
  foreach my $val (@$valref) {
    push(@$Line, [ "\t$val"]);
  }
}

my $nextpnum;			# The position of the next parameter

# Declare a new local identifier for the current function
sub new_localid
{
  my ($fn,$id)= @_;

  # If we already have a definition for this local,
  # ignore it if this is from a prototype
  if (defined($Local{$fn}{$id})) {
    if ($Function{$fn} eq 'proto') {
      # However, check that it's in the same position
      Die("$fn: $id not in same position as prototype")
	if ($PPosn{$fn}[$nextpnum] ne $id);
      $nextpnum++; return;
    }

    Die("$fn: $id local already declared");
  }

  # Define the local and store its position
  $Local{$fn}{$id}=1;
  $PPosn{$fn}[$nextpnum++]= $id;
}

# Given an identifier arrayref, see if this is a local or
# a global. Return a local identifier ref or the original.
# Return a list, not an arrayref.
sub getid
{
  my ($idref, $how)= @_;
  return(undef) if (!defined($idref));
  my ($id, $ind, $offset)= @$idref;
  $id= "$last_functionid.$id"
		if (defined($Local{$last_functionid}{$id}));

  # Arrays are hard because we have to create a pointer to
  # the element, and then we can return the pointer. We may
  # also have to temporarily store the AC before we create
  # the pointer
  if ($ind eq 'array') {
    my ($offid, $offind) = @$offset;

    Die("can't index an array more than once") if ($offind eq 'array');
    ($offid, $offind)= getid($offset);

    # If this isn't a lac, save the current AC
    push(@$Line, ['dac .temp']) if ($how ne 'lac');

    # Get the pointer to the array element into ptr1
    # and then get back the saved AC
    push(@$Line, ['lac', $id]);
    push(@$Line, ['tad', $offid, $offind]);
    push(@$Line, ['dac .ptr1']);
    push(@$Line, ['lac .temp']) if ($how ne 'lac');
    $id='.ptr1'; $ind='i';
  }
  return($id, $ind);
}

#### LABEL CODE
my @loopstack;	# Stack of labels for each loop
my @ifstack;	# Stack of labels for each selection statement
my $lifref;	# Points to either the loopstack or the ifstack

# Return a new label
my $label=0;
sub new_label
{
  $label++;
  return("LL$label");
}

# Declare a new function. The definition is always "proto" when we are
# called, and stays that way after a function prototype. It changes to
# "real" when the function is really defined.
sub new_functionid
{
  my ($id, $definition)= @_;
  Die("$id function conflicts with global") if (defined($Global{$id}));
  Die("$id function already declared")
	if (defined($Function{$id}) && $Function{$id} eq "real");
  $Function{$id}=$definition;
  $nextpnum=0;		# Params for this function start at 0
  $last_functionid=$id;
}

# Print out the label of the function just created
sub print_function_label
{
  $Function{$last_functionid}= 'real';
  push(@$Line, [ "$last_functionid: 0" ]);
}

# Check and return a function name. Translate system calls to
# ones starting with a dot, so we don't tread on the assembler's toes
sub get_functionid
{
  my $id= shift;
  $id= $Syscall{$id} if (defined($Syscall{$id}));
  Die("$id function not yet declared") if (!defined($Function{$id}));
  return($id);
}


### STRINGLIST CODE
my @Stringlit;		# List of string literals and their identifiers

my $strlabel=0;
# Return a new string label
sub new_strlabel
{
  $strlabel++;
  return("STR$strlabel");
}

# Add a new string literal. Make a label if none
sub add_strliteral
{
  my ($s, $label)= @_;
  $label= new_strlabel() if (!defined($label));
  push(@Stringlit, [ $s, $label ]);
  return($label);
}

# Write out all the string literals and their labels
sub write_strliterals
{
  foreach my $sref (@Stringlit) {
    my ($s, $label)= @$sref;
    push(@$Line, ["$label: $label.base"]);
    push(@$Line, ["$label.base:"]);
    foreach my $i (0 .. length($s)-1) {
      push(@$Line, ["\t" . ord( substr($s, $i, 1))]);
    }
    push(@$Line, ["\t0"]);
  }
}

### PDP-7 specific code
# Expand an identifier and load it into the AC
sub lac
{
  my $id= shift;
  return if (!defined($id));
  push(@$Line, ['lac', getid($id, 'lac')]);
}

# Expand an identifier and store into it from the AC
sub dac
{
  my $id= shift;
  return if (!defined($id));
  push(@$Line, ['dac', getid($id, 'dac')]);
}

# Temporarily store the AC and return an
# identifier for the temporary storage
sub tempdac
{
  push(@$Line, ['dac', '.temp']);
  return([ '.temp', '' ]);
}

# Create a new constant to be written
# out later
sub new_const
{
  my $c= shift;
  my $label;
  if ($c<0) {
    my $absc= abs($c);
    $label= "m$absc";
  } else {
    $label= "d$c";
  }
  $Const{$label}=$c;
  return($label);
}

%}

%%

translation_unit:
      global_declarations 
;
global_declarations:
      global_declaration
    | global_declaration global_declarations 
;
global_declaration:
      type_declarator.d ';'
	{ new_globalid($d,'',[0]); }
    | type_declarator.d '=' CONSTANT.c ';'
	{ new_globalid($d, '',[$c]); }
    | array_declaration
    | function_definition 
;
local_declaration:
      type_declarator.p ';'
	{ new_localid($last_functionid, $p); }
    | type_declarator.p '=' bit_expression.e ';' 
	{ new_localid($last_functionid, $p);
	  lac($e); dac([$p,'']);
	}
;
array_declaration:
      type_declarator.d '[' CONSTANT.c ']' ';'
        {
          # Build a list of zero values
          my @zlist;
          foreach my $count (1 .. $c) {
            push(@zlist, 0);
          }
          new_globalid($d, 'array', \@zlist);
        }
    | type_declarator.d '[' ']' '=' '{' constant_list.l '}' ';'
	{ new_globalid($d, 'array', $l); }
    | type_declarator.d '[' ']' '=' STRINGLITERAL.s ';' 
        {
          add_strliteral($s, $d);
          new_globalid($d, 'array', undef);
        }
;
constant_list:
      CONSTANT.c
	{ # Return an arrayref with one element
	  [ $c ];
	}
    | constant_list.l ',' CONSTANT.c
	{ # Return an arrayref with an extra element
          push(@$l, $c); $l;
	}
;
type_declarator:
      type_specifier pointer IDENTIFIER.i
	{ $i; }
    | type_specifier IDENTIFIER.i
	{ $i; }
;
type_specifier:
      VOID
    | CHAR
    | INT 
;
pointer:
      '*' 
;
function_definition:
      function_declarator ';'
    | function_declarator
	{ print_function_label(); }
      compound_statement
	{ push(@$Line, ["jmp $last_functionid i"]); }
;
function_declarator:
      type_declarator.f '(' ')'
	{ new_functionid($f,'proto'); }
    | type_declarator.f '('
	{ new_functionid($f,'proto'); }
      parameter_list ')'
;
parameter_list:
      parameter_declaration
    | parameter_list ',' parameter_declaration
;
parameter_declaration:
      type_declarator.p 
	{ new_localid($last_functionid, $p); }
;
function_expression:
      IDENTIFIER.f '(' ')'
	{ push(@$Line, ['jms', get_functionid($f) ]); undef; }
    | IDENTIFIER.f '('
	{ $nextpnum=0; $calledfn= $f; }
      argument_list ')' 
	{ push(@$Line, ['jms', get_functionid($f) ]); undef; }
;
argument_list:
      argument.a
	{ # Get the name of the function's param at this position
	  my $pname= $PPosn{$calledfn}[$nextpnum++];
	  lac($a); dac(["$calledfn.$pname",'']);
	}
    | argument_list ',' argument.a
	{ # Get the name of the function's param at this position
	  my $pname= $PPosn{$calledfn}[$nextpnum++];
	  lac($a); dac(["$calledfn.$pname",'']);
	}
;

# Expressions are represented as an arrayref with two or
# three elements: the identifier, 'i' if it needs an
# indirect reference, and an optional third value which
# is the array offset expression (i.e. also an arrayref).
# The second element is 'array' if there is an offset.
lvalue_expression:
      IDENTIFIER.i
	{ [ $i, '' ]; }
    | '*' IDENTIFIER.i
	{ [ $i, 'i' ]; }
    | IDENTIFIER.i '[' bit_expression.e ']'
	{ [ $i, 'array', $e ]; }
;
argument:
      lvalue_expression
    | CONSTANT.c
	{ $c= new_const($c); [ $c, '']; }
    | STRINGLITERAL.s
	{ my $id= add_strliteral($s);
	  [ $id, '' ]; }
;
basic_expression:
      argument
    | function_expression
    | '(' bit_expression.e ')'
	{ $e; }
;
multiplicative_expression:
      basic_expression
    | multiplicative_expression.lhs '*' basic_expression.rhs
	{ lac($rhs);
  	  push(@$Line, ['dac .+4']);
	  lac($lhs);
  	  push(@$Line, ['cll; mul; ..; lacq']);
	  undef;
	}
    | multiplicative_expression.lhs '/' basic_expression.rhs
	{ lac($rhs);
  	  push(@$Line, ['dac .+4']);
	  lac($lhs);
  	  push(@$Line, ['cll; idiv; ..; lacq']);
	  undef;
	}
    | multiplicative_expression.lhs '%' basic_expression.rhs
	{ lac($rhs);
  	  push(@$Line, ['dac .+4']);
	  lac($lhs);
  	  push(@$Line, ['cll; idiv; ..']);
	  undef;
	}
;
additive_expression:
      multiplicative_expression
    | additive_expression.lhs '+' multiplicative_expression.rhs
	{ lac($lhs);
  	  push(@$Line, ['tad', getid($rhs, 'rhs')]);
	  undef;
	}
    | additive_expression.lhs '-' multiplicative_expression.rhs
	{ lac($lhs);
  	  push(@$Line, ['cma']);
  	  push(@$Line, ['tad', getid($rhs, 'rhs') ]);
  	  push(@$Line, ['cma']);
	  undef;
	}
;
shift_expression:
      additive_expression
    | shift_expression.lhs LEFT_OP CONSTANT.c
	{ lac($lhs);
  	  push(@$Line, ['lls', $c]);
	}
    | shift_expression.lhs RIGHT_OP CONSTANT.c
	{ lac($lhs);
  	  push(@$Line, ['lrss', $c]);
	}
;
bit_expression:
      shift_expression
    | bit_expression.lhs '&' shift_expression.rhs
	{ ($rhs,$lhs)= ($lhs,$rhs) if (!defined($rhs));
	  lac($lhs);
  	  push(@$Line, ['and', getid($rhs, 'rhs') ]);
	  undef;
	}
    | bit_expression.lhs '^' shift_expression.rhs
	{ ($rhs,$lhs)= ($lhs,$rhs) if (!defined($rhs));
	  lac($lhs);
  	  push(@$Line, ['xor', getid($rhs, 'rhs') ]);
	  undef;
	}
    | bit_expression.lhs '|' shift_expression.rhs
	{ ($rhs,$lhs)= ($lhs,$rhs) if (!defined($rhs));
	  lac($rhs);
  	  push(@$Line, ['lmq']);
	  lac($lhs);
  	  push(@$Line, ['omq']);
	  undef;
	}
;
relational_expression:
      bit_expression
    | relational_expression.lhs '<' bit_expression.rhs
	{
	  lac($lhs);
	  push(@$Line, ['cma']);
	  push(@$Line, ['tad', getid($rhs, 'rhs') ]);
	  push(@$Line, ['cma']);
	  push(@$Line, ['sma']);
          push(@$Line, ["  jmp $lifref->[-1]->[0]"]);
	}
    | relational_expression.lhs '>' bit_expression.rhs
	{
	  lac($rhs);
	  push(@$Line, ['cma']);
	  push(@$Line, ['tad', getid($lhs, 'rhs') ]);
	  push(@$Line, ['cma']);
	  push(@$Line, ['sma']);
          push(@$Line, ["  jmp $lifref->[-1]->[0]"]);
	}
    | relational_expression.lhs LE_OP bit_expression.rhs
	{
	  lac($rhs);
	  push(@$Line, ['cma']);
	  push(@$Line, ['tad', getid($lhs, 'rhs') ]);
	  push(@$Line, ['cma']);
	  push(@$Line, ['spa']);
          push(@$Line, ["  jmp $lifref->[-1]->[0]"]);
	}
    | relational_expression.lhs GE_OP bit_expression.rhs
	{
	  lac($lhs);
	  push(@$Line, ['cma']);
	  push(@$Line, ['tad', getid($rhs, 'rhs') ]);
	  push(@$Line, ['cma']);
	  push(@$Line, ['spa']);
          push(@$Line, ["  jmp $lifref->[-1]->[0]"]);
	}
    | relational_expression.lhs EQ_OP bit_expression.rhs
	{
	  my $third= new_label();
	  lac($lhs);
	  push(@$Line, ['sad', getid($rhs, 'rhs') ]);
          push(@$Line, ["  jmp $third"]);
          push(@$Line, ["jmp $lifref->[-1]->[0]"]);
          push(@$Line, ["$third:"]);
	}
    | relational_expression.lhs NE_OP bit_expression.rhs
	{
	  lac($lhs);
	  push(@$Line, ['sad', getid($rhs, 'rhs') ]);
          push(@$Line, ["  jmp $lifref->[-1]->[0]"]);
	}
;
statement:
      labeled_statement
    | assignment_statement ';'
    | function_expression ';'
    | selection_statement
    | iteration_statement
    | jump_statement
    | compound_statement
    | postop_statement 
;
labeled_statement:
      IDENTIFIER.i ':'
  	{ push(@$Line, [ "$i:" ]); }
      statement
;
assignment_statement:
    lvalue_expression.l '=' bit_expression.e
	{ lac($e); dac($l); }
;
selection_statement:
      if_head %prec WEAK
        { push(@$Line, ["$ifstack[-1]->[0]:"]);
          pop(@ifstack);
        }
    | if_head
	{ push(@$Line, ["jmp $ifstack[-1]->[1]"]);
          push(@$Line, ["$ifstack[-1]->[0]:"]); 
	}
      ELSE statement
        { push(@$Line, ["$ifstack[-1]->[1]:"]);
	  pop(@ifstack);
	}
;
if_head:
      IF
        { # Generate false and end labels for this IF
          my $false= new_label();
          my $end= new_label();
          push(@ifstack, [ $false, $end ]);
	  $lifref= \@ifstack;
        }
      '(' relational_expression ')' statement 
;
iteration_statement:
      WHILE
        { # Generate start and end labels for this loop
          my $start= new_label();
          my $end= new_label();
          push(@loopstack, [ $end, $start ]);
	  $lifref= \@loopstack;
          push(@$Line, ["$start:"]);
        }
      '(' relational_expression ')'
      statement
        { push(@$Line, ["jmp $loopstack[-1]->[1]"]);
          push(@$Line, ["$loopstack[-1]->[0]:"]);
	  pop(@loopstack);
	}
    | DO
        { # Generate start and end labels for this loop
          my $start= new_label();
          my $end= new_label();
          push(@loopstack, [ $end, $start ]);
	  $lifref= \@loopstack;
          push(@$Line, ["$start:"]);
        }
      statement WHILE '(' relational_expression ')' ';'
        { push(@$Line, ["jmp $loopstack[-1]->[1]"]);
          push(@$Line, ["$loopstack[-1]->[0]:"]);
	  pop(@loopstack);
	}
    | FOR
      '(' assignment_statement ';'
        { # Generate start and end labels for this loop
          my $start= new_label();
          my $end= new_label();
          push(@loopstack, [ $end, $start ]);
	  $lifref= \@loopstack;
          push(@$Line, ["$start:"]);
        }
      relational_expression ';'
        { # Move all the current lines over to FinalLine
          # and empty $Line for the third statement
          push(@FinalLine, $Line); $Line= [];
        }
      third_for_expression ')' statement
        {
          # Move all the current lines over to FinalLine
          push(@FinalLine, $Line); $Line= [];
          # Pop off the most recent FOR third statement code
          # and save in the FinalLine array
          push(@FinalLine, pop(@Forstack));
          # Now add in the jump at the end of the loop
          push(@$Line, ["jmp $loopstack[-1]->[1]"]);
          push(@$Line, ["$loopstack[-1]->[0]:"]);
	  pop(@loopstack);
        }
;
third_for_expression:
      assignment_statement
        {
          # Push the third statement code onto the Forstack
          push(@Forstack, $Line); $Line= [];
        }
    | postop_expression
        {
          # Push the third statement code onto the Forstack
          push(@Forstack, $Line); $Line= [];
        }
;

jump_statement:
      GOTO IDENTIFIER.i ';'
  	{ push(@$Line, [ "jmp $i" ]); }
    | CONTINUE ';'
	{ push(@$Line, ["jmp $loopstack[-1]->[1]"]); }
    | BREAK ';'
	{ push(@$Line, ["jmp $loopstack[-1]->[0]"]); }
    | RETURN ';'
	{ push(@$Line, ["jmp $last_functionid i"]); }
    | RETURN '(' bit_expression.e ')' ';' 
	{ lac($e); push(@$Line, ["jmp $last_functionid i"]); }
;
compound_statement:
      '{' '}'
    | '{' statement_list '}'
    | '{' declaration_list statement_list '}' 
;
postop_statement:
      postop_expression ';' 
;
postop_expression:
      lvalue_expression.l INC_OP
	{ push(@$Line, ['isz', getid($l, 'lac') ]); 
	  push(@$Line, ['nop']); 
	}
    | lvalue_expression.l DEC_OP 
	{ my ($id, $ind)= getid($l, 'lac');
	  push(@$Line, ['-1', '; tad', $id, $ind ]);
	  push(@$Line, ['dac', $id, $ind ]);
	}
;
declaration_list:
      local_declaration
    | local_declaration declaration_list 
;
statement_list:
      statement
    | statement statement_list 
;

%%

sub TERMINAL::info { $_[0]{attr} }
$Parse::Eyapp::Node::INDENT = 2;

sub _Error {
    print("Token " . $_[0]->YYCurval .
          " unexpected on line $linenumber of $Basename.a\n");
    print("Expecting one of: " . join(' ', $_[0]->YYExpect) . "\n");
}

sub _Lexer {
    my($parser)=shift;

    # Loop until we can return a token or there are no lines left
    while (1) {
      # Return a token if possible
      if (@TokenQueue) {
        my $tokptr= shift(@TokenQueue);
        #print("Return token $tokptr->[0] $tokptr->[1]\n");
        return(@{ $tokptr });
      }

      # No tokens, so read a line in. Exit if no lines left
      $_= <$IN> || return('',undef);
      $linenumber++;

      # Pre-processor line
      if (m{^#}) {
	# Pre-processor current line number
        if (m{^#\s*(\d+)}) {
          $linenumber= $1-1;
	}
	# Read in another line
        next;
      }

      # Remove any // comments and leading whitespace
      s{\s*\/\/.*}{}; s{^\s*}{};

      # Break the line up into tokens
      while ($_) {
        if ($incomment) {
          # If we find the end of a multi-line comment, mark out
          if (s{.*\*/\s*}{}) { $incomment = 0; next; }
          # Didn't find one, so get out of this line loop
          # as the whole line is part of the comment.
          last;
        }
        if (s{^/\*\s*}{}) { $incomment = 1; next; }
        if (s{^([A-Za-z_][A-Za-z0-9_]*)\s*}{}) {
          # Push a keyword if found
          if ($Keyword{$1}) { push(@TokenQueue,[$Keyword{$1},$1]); next; }
          push(@TokenQueue,['IDENTIFIER',$1]); next;
        }
        if (s{^0([0-7]+)\s*}{}) {
          push(@TokenQueue,['CONSTANT',oct($1)]); next;
	}
        if (s{^(-?\d+)\s*}{}) {
          push(@TokenQueue,['CONSTANT',$1]); next;
        }
        if (s{^'\\n'\s*}{}) {
          push(@TokenQueue,['CONSTANT',10]); next;
        }
        if (s{^'\\t'\s*}{}) {
          push(@TokenQueue,['CONSTANT',9]); next;
        }
        if (s{^'\\0'\s*}{}) {
          push(@TokenQueue,['CONSTANT',0]); next;
        }
        if (s{^'([^'])'\s*}{}) {
          push(@TokenQueue,['CONSTANT',ord($1)]); next;
        }
	# Two character constant e.g 'ul'
        if (s{^'([^'])([^'])'\s*}{}) {
          push(@TokenQueue,['CONSTANT',ord($1)<<9 | ord($2)]); next;
        }
        if (s{^"([^"]*)"\s*}{}) {
	  # Change literal \n \t \0
	  my $str= $1;
	  $str=~ s/\\n/\n/g; $str=~ s/\\t/\t/g; $str=~ s/\\0/\0/g;
          push(@TokenQueue,['STRINGLITERAL',$str]); next;
        }
        if (s{^(<<)\s*}{}) {
          push(@TokenQueue,['LEFT_OP',$1]); next;
        }
        if (s{^(>>)\s*}{}) {
          push(@TokenQueue,['RIGHT_OP',$1]); next;
        }
        if (s{^(\+\+)\s*}{}) {
          push(@TokenQueue,['INC_OP',$1]); next;
        }
        if (s{^(\-\-)\s*}{}) {
          push(@TokenQueue,['DEC_OP',$1]); next;
        }
        if (s{^(==)\s*}{}) {
          push(@TokenQueue,['EQ_OP',$1]); next;
	}
        if (s{^(!=)\s*}{}) {
          push(@TokenQueue,['NE_OP',$1]); next;
	}
        if (s{^(<=)\s*}{}) {
          push(@TokenQueue,['LE_OP',$1]); next;
	}
        if (s{^(>=)\s*}{}) {
          push(@TokenQueue,['GE_OP',$1]); next;
	}
        if (s{^([-+*/%&|^<>=,;:])\s*}{}) {
          push(@TokenQueue,[$1,$1]); next;
        }
        if (s{^([\(\)\{\}\[\]])\s*}{}) {
          push(@TokenQueue,[$1,$1]); next;
        }
        Die("Unrecognised token on line: $_\n");
      }
    }
}

sub Run {
    my($self,$infile)= @_;

    # Create some globals to hold the filehandles and the basename
    $Basename = $infile;
    $Basename =~ s/\.[a-z]$//;

    # Open the in/out files
    open( $IN, "-|", "cpp -nostdinc $infile")
    				|| die("Cannot open $infile: $!");
    my $outfile = $Basename . ".s";
    open( $OUT, ">", $outfile ) || die("Cannot write $outfile: $!");
    $incomment  = 0;
    $linenumber = 0;

    new_globalid('.temp','',[0]);
    new_globalid('.ptr1','',[0]);

    # Parse the class which is in this file
    my $t= $self->YYParse( yylex => \&_Lexer, yyerror => \&_Error);

    write_strliterals();
    push(@FinalLine, $Line);

    # Print out the lines of code
    foreach my $lref (@FinalLine) {
      foreach my $l (@$lref) {
        my $line= join(' ', @$l);
        $line= "\t" . $line if (!($l->[0]=~ m{:}));
        print($OUT "$line\n");
      }
    }

    # Print out constants
    foreach my $c (keys(%Const)) {
      print($OUT "$c: $Const{$c}\n");
    }

    # Print out local variables
    foreach my $fn (keys(%PPosn)) {
      foreach my $id (@{ $PPosn{$fn}}) {
        print($OUT "$fn.$id: 0\n");
      }
    }

    # Close the in/out files
    close($IN);
    close($OUT);
}


### MAIN PROGRAM ###

# Error if no argument
die("Usage: $0 [-O] file.h\n") if (@ARGV < 1);

# Get any optional arguments
while ( defined( $ARGV[0] ) && ( $ARGV[0] =~ m{^-} ) ) {

    # -O: optimise
    if ( $ARGV[0] eq "-O" ) {
        $Optimise = 1;
        shift(@ARGV);
    }
}

die("No input file $ARGV[0]\n") if (! -f $ARGV[0]);

my($parser)=new h;
$parser->Run($ARGV[0]);
exit(0);
