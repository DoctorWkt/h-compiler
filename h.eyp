# h.eyp: Compiler for Warren's simple H language.
# All variables are global, char and int are the same.
# No recursion.
#
# (c) Warren Toomey, 2016. GPL3 license.
#
%token IDENTIFIER CONSTANT STRINGLITERAL
%token INC_OP DEC_OP LEFT_OP RIGHT_OP LE_OP GE_OP EQ_OP NE_OP 
%token CHAR INT VOID 
%token IF ELSE WHILE DO GOTO CONTINUE BREAK RETURN 
%left WEAK 
%right ELSE 
%start translation_unit 

%{
use Data::Dumper;
### GLOBALS ###
my ( $IN, $OUT );    # Filehandles for input & output files
my $Basename;        # Basename of both files
my @TokenQueue;      # Stack of tokens not yet read
my $incomment;       # Are we in a multi-line comment?
my $linenumber;      # What line number we are on
my @Constlist;       # List of constants in array initialisation
my %Global;          # List of known global identifiers
my %Local;           # List of known per-function identifiers
		     # ->{fnname}->{id}
my %PPosn= (
    'putchar' => [ 'c' ],
    'printn' => [ 'n' ],
);
my $last_functionid="";
my $calledfn="";
my %Const;
my @FinalLine;       # Array of references to arrays which contain all
		     # the generated assembly code lines
my @Forstack;	     # Stack of line arrayrefs of third expressions in FOR

my %Function=(       # List of known function identifiers
    'printn' => 'proto',
    'getchar' => 'proto',
    'putchar' => 'proto',
    '.exit' => 'proto',
);
		     # List of assembly code lines we have generated
		     # but which have not yet been added to the final
		     # set of lines in @FinalLine
my $Line=[ ['jms','main'],['sys','exit'] ];

		     # List of keywords in the grammar
my %Keyword= (
  'break' => 'BREAK',
  'char' => 'CHAR',
  'continue' => 'CONTINUE',
  'do' => 'DO',
  'else' => 'ELSE',
  'for' => 'FOR',
  'goto' => 'GOTO',
  'if' => 'IF',
  'int' => 'INT',
  'return' => 'RETURN',
  'switch' => 'SWITCH',
  'void' => 'VOID',
  'while' => 'WHILE',
);
		     # List of known system calls to translate
my %Syscall= (
  'exit' => '.exit',
);

# Simple method to print error and die
sub Die
{
  my $err= shift;
  print(STDERR "$err on $Basename.a line $linenumber\n");
  exit(1);
}


# Declare a new global identifier id. If there are
# values print the label and values now.
sub new_globalid
{
  my ($id, $type, $valref)= @_;
  Die("$id global already declared") if (defined($Global{$id}));
  $Global{$id}=$type;
  return if (!defined($valref));
  if ($type eq "array") {
    push(@$Line, [ "$id: $id.base"]);
    push(@$Line, [ "$id.base:"]);
  } else {
    push(@$Line, [ "$id:"]);
  }
  foreach my $val (@$valref) {
    push(@$Line, [ "\t$val"]);
  }
}

my $nextpnum;
sub new_localid
{
  my ($fn,$id)= @_;
  Die("$fn: $id local already declared") if (defined($Local{$fn}{$id}));
  $Local{$fn}{$id}=1;
  $PPosn{$fn}[$nextpnum++]= $id;	# Save the param's position
}

# Given an identifier arrayref, see if this is a local or
# a global. Return a local identifier ref or the original
# but as a list, not as an arrayref.
sub getid
{
  my ($idref, $how)= @_;
  return(undef) if (!defined($idref));
  my ($id, $ind, $offset)= @$idref;
  $id= "$last_functionid.$id"
		if (defined($Local{$last_functionid}{$id}));
  if ($ind eq 'array') {
    my ($offid, $offind) = @$offset;
    Die("can't index an array more than once") if ($offind eq 'array');
    ($offid, $offind)= getid($offset);
    push(@$Line, [ "\t\t\t\" getid array $id, off $offid $offind, how $how" ]);

    # If this isn't a lac, save the current AC
    push(@$Line, ['dac .temp']) if ($how ne 'lac');

    # Get the pointer to the array element into ptr2
    # and then get back the saved AC
    push(@$Line, ['lac', $id]);
    push(@$Line, ['tad', $offid, $offind]);
    push(@$Line, ['dac .ptr2']);
    push(@$Line, ['lac .temp']) if ($how ne 'lac');
    $id='.ptr2'; $ind='i';
  }
  return($id, $ind);
}

#### LABEL CODE
my $label=0;
my @loopstack;
my @ifstack;
my $lifref;	# Points to either the loopstack or the ifstack

# Return a new label
sub new_label
{
  $label++;
  return("LL$label");
}

# Declare a new function. If definition is "real", this is a real function
# definition, so save this in the %Function hash and create a label. If
# it is just "proto", then save it as such and no label
sub new_functionid
{
  my ($id, $definition)= @_;
  Die("$id function conflicts with global") if (defined($Global{$id}));
  Die("$id function already declared")
	if (defined($Function{$id}) && $Function{$id} eq "real");
  $Function{$id}=$definition;
  push(@$Line, [ "$id: 0" ]) if ($definition eq "real");
  $last_functionid=$id;
  $nextpnum=0;		# params for this function start at 0
}

# Check and return a function name. Translate system calls to
# ones starting with a dot, so we don't tread on the assembler's toes
sub get_functionid
{
  my $id= shift;
  $id= $Syscall{$id} if (defined($Syscall{$id}));
  Die("$id function not yet declared") if (!defined($Function{$id}));
  return($id);
}


### STRINGLIST CODE
my @Stringlit;		# List of string literals and their identifiers
my $strlabel=0;

# Return a new string label
sub new_strlabel
{
  $strlabel++;
  return("STR$strlabel");
}

# Add a new string literal. Make a label if none
sub add_strliteral
{
  my ($s, $label)= @_;
  $label= new_strlabel() if (!defined($label));
  push(@Stringlit, [ $s, $label ]);
  return($label);
}

# Write out all the string literals and their labels
sub write_strliterals
{
  foreach my $sref (@Stringlit) {
    my ($s, $label)= @$sref;
    push(@$Line, ["$label: $label.base"]);
    push(@$Line, ["$label.base:"]);
    foreach my $i (0 .. length($s)-1) {
      push(@$Line, ["\t" . ord( substr($s, $i, 1))]);
    }
    push(@$Line, ["\t0"]);
  }
}

sub lac
{
  my $id= shift;
  return if (!defined($id));
  push(@$Line, ['lac', getid($id, 'lac')]);
}

sub dac
{
  my $id= shift;
  return if (!defined($id));
  push(@$Line, ['dac', getid($id, 'dac')]);
}

sub tempdac
{
  push(@$Line, ['dac', '.temp']);
  return([ '.temp', '' ]);
}

sub new_const
{
  my $c= shift;
  if ($c<0) {
    $Const{"m$c"}=$c;
  } else {
    $Const{"d$c"}=$c;
  }
}


%}

%%

translation_unit:
      global_declarations 
;
global_declarations:
      global_declaration
    | global_declaration global_declarations 
;
global_declaration:
      type_declarator.d ';'
	{ new_globalid($d,'',[0]); }
    | type_declarator.d '=' CONSTANT.c ';'
	{ new_globalid($d, '',[$c]); }
    | array_declaration
    | function_definition 
;
local_declaration:
      type_declarator.p ';'
	{ new_localid($last_functionid, $p); }
    | type_declarator.p '=' bit_expression.e ';' 
	{ new_localid($last_functionid, $p);
	  lac($e); dac([$p,'']);
	}
;
array_declaration:
      type_declarator.d '[' CONSTANT.c ']' ';'
        {
          # Build a list of zero values
          my @zlist;
          foreach my $count (1 .. $c) {
            push(@zlist, 0);
          }
          new_globalid($d, 'array', \@zlist);
        }
    | type_declarator.d '[' ']' '=' '{' constant_list.l '}' ';'
	{ new_globalid($d, 'array', $l); }
    | type_declarator.d '[' ']' '=' STRINGLITERAL.s ';' 
        {
          add_strliteral($s, $d);
          new_globalid($d, 'array', undef);
        }
;
constant_list:
      CONSTANT.c
	{ # Return an arrayref with one element
	  [ $c ];
	}
    | constant_list.l ',' CONSTANT.c
	{ # Return an arrayref with an extra element
          push(@$l, $c); $l;
	}
;
type_declarator:
      type_specifier pointer IDENTIFIER.i
	{ $i; }
    | type_specifier IDENTIFIER.i
	{ $i; }
;
type_specifier:
      VOID
    | CHAR
    | INT 
;
pointer:
      '*' 
;
function_definition:
      function_declarator ';'
    | function_declarator compound_statement
	{ push(@$Line, ["jmp $last_functionid i"]); }
;
function_declarator:
      type_declarator.f '(' ')'
	{ new_functionid($f,'real'); }
    | type_declarator.f '('
	{ new_functionid($f,'real'); }
      parameter_list ')'
;
parameter_list:
      parameter_declaration
    | parameter_list ',' parameter_declaration
;
parameter_declaration:
      type_declarator.p 
	{ new_localid($last_functionid, $p); }
;
function_expression:
      IDENTIFIER.f '(' ')'
	{ push(@$Line, ['jms', get_functionid($f) ]); undef; }
    | IDENTIFIER.f '('
	{ $nextpnum=0; $calledfn= $f; }
      argument_list ')' 
	{ push(@$Line, ['jms', get_functionid($f) ]); undef; }
;
argument_list:
      argument.a
	{ # Get the name of the function's param at this position
	  my $pname= $PPosn{$calledfn}[$nextpnum++];
	  lac($a); dac(["$calledfn.$pname",'']);
	}
    | argument_list ',' argument.a
	{ # Get the name of the function's param at this position
	  my $pname= $PPosn{$calledfn}[$nextpnum++];
	  lac($a); dac(["$calledfn.$pname",'']);
	}
;
lvalue_expression:
      IDENTIFIER.i
	{ [ $i, '' ]; }
    | '*' IDENTIFIER.i
	{ [ $i, 'i' ]; }
    | IDENTIFIER.i '[' bit_expression.e ']'
	{ [ $i, 'array', $e ]; }
;
argument:
      lvalue_expression
    | CONSTANT.c
	{ new_const($c); $c= ($c < 0) ? [ "m$c", ''] : ["d$c", '']; }
    | STRINGLITERAL.s
	{ my $id= add_strliteral($s);
	  [ $id, '' ]; }
;
basic_expression:
      argument
    | function_expression
    | '(' bit_expression.e ')'
	{ $e; }
;
multiplicative_expression:
      basic_expression
    | multiplicative_expression.lhs '*' basic_expression.rhs
	{ $lhs= tempdac() if (!defined($lhs));
	  if (!defined($rhs)) {
  	    push(@$Line, ['panic!']);
	  } else {
	    lac($rhs);
  	    push(@$Line, ['dac .+4']);
	  }
	  lac($lhs);
  	  push(@$Line, ['cll; mul; ..; lacq']);
	  undef;
	}
    | multiplicative_expression.lhs '/' basic_expression.rhs
	{ $lhs= tempdac() if (!defined($lhs));
	  if (!defined($rhs)) {
  	    push(@$Line, ['panic!']);
	  } else {
	    lac($rhs);
  	    push(@$Line, ['dac .+4']);
	  }
	  lac($lhs);
  	  push(@$Line, ['cll; idiv; ..; lacq']);
	  undef;
	}
    | multiplicative_expression.lhs '%' basic_expression.rhs
	{ $lhs= tempdac() if (!defined($lhs));
	  if (!defined($rhs)) {
  	    push(@$Line, ['panic!']);
	  } else {
	    lac($rhs);
  	    push(@$Line, ['dac .+4']);
	  }
	  lac($lhs);
  	  push(@$Line, ['cll; idiv; ..']);
	  undef;
	}
;
additive_expression:
      multiplicative_expression
    | additive_expression.lhs '+' multiplicative_expression.rhs
	{ ($rhs,$lhs)= ($lhs,$rhs) if (!defined($rhs));
	  lac($lhs);
  	  push(@$Line, ['tad', getid($rhs, 'rhs'),"\t\t\" add" ]);
	  undef;
	}
    | additive_expression.lhs '-' multiplicative_expression.rhs
	{ $rhs= tempdac() if (!defined($rhs));
	  lac($lhs);
  	  push(@$Line, ['cma']);
  	  push(@$Line, ['tad', getid($rhs, 'rhs') ]);
  	  push(@$Line, ['cma']);
	  undef;
	}
;
shift_expression:
      additive_expression
    | shift_expression.lhs LEFT_OP CONSTANT.c
	{ lac($lhs);
  	  push(@$Line, ['lls', $c]);
	}
    | shift_expression.lhs RIGHT_OP CONSTANT.c
	{ lac($lhs);
  	  push(@$Line, ['lrss', $c]);
	}
;
bit_expression:
      shift_expression
    | bit_expression.lhs '&' shift_expression.rhs
	{ ($rhs,$lhs)= ($lhs,$rhs) if (!defined($rhs));
	  lac($lhs);
  	  push(@$Line, ['and', getid($rhs, 'rhs') ]);
	  undef;
	}
    | bit_expression.lhs '^' shift_expression.rhs
	{ ($rhs,$lhs)= ($lhs,$rhs) if (!defined($rhs));
	  lac($lhs);
  	  push(@$Line, ['xor', getid($rhs, 'rhs') ]);
	  undef;
	}
    | bit_expression.lhs '|' shift_expression.rhs
	{ ($rhs,$lhs)= ($lhs,$rhs) if (!defined($rhs));
	  lac($rhs);
  	  push(@$Line, ['lmq']);
	  lac($lhs);
  	  push(@$Line, ['omq']);
	  undef;
	}
;
relational_expression:
      bit_expression
    | relational_expression '<' bit_expression
    | relational_expression '>' bit_expression
    | relational_expression LE_OP bit_expression
    | relational_expression GE_OP bit_expression
    | relational_expression.lhs EQ_OP bit_expression.rhs
	{
	  # Use sad if rhs exists
	  if (defined($rhs)) {
	    my $third= new_label();
	    lac($lhs);
	    push(@$Line, ['sad', getid($rhs, 'rhs') ]);
            push(@$Line, ["  jmp $third"]);
            push(@$Line, ["jmp $lifref->[-1]->[0]\t\t\" NE"]);
            push(@$Line, ["$third:\t\t\" third"]);
	  }
	}
    | relational_expression.lhs NE_OP bit_expression.rhs
	{
	  # Use sad if rhs exists
	  if (defined($rhs)) {
	    lac($lhs);
	    push(@$Line, ['sad', getid($rhs, 'rhs') ]);
            push(@$Line, ["  jmp $lifref->[-1]->[0]\t\t\" EQ"]);
	  }
	}
;
statement:
      labeled_statement
    | assignment_statement ';'
    | function_expression ';'
    | selection_statement
    | iteration_statement
    | jump_statement
    | compound_statement
    | postop_statement 
;
labeled_statement:
      IDENTIFIER.i ':'
  	{ push(@$Line, [ "$i:" ]); }
      statement
;
assignment_statement:
    lvalue_expression.l '=' bit_expression.e
	{ lac($e); dac($l); }
;
selection_statement:
      if_head %prec WEAK
        { push(@$Line, ["$ifstack[-1]->[0]:\t\t\" IFsingle top"]);
          pop(@ifstack);
        }
    | if_head
	{ push(@$Line, ["jmp $ifstack[-1]->[1]"]);
          push(@$Line, ["$ifstack[-1]->[0]:\t\t\" IFelse top"]); 
	}
      ELSE statement
        { push(@$Line, ["$ifstack[-1]->[1]:\t\t\" ELSE"]);
	  pop(@ifstack);
	}
;
if_head:
      IF
        { # Generate false and end labels for this IF
          my $false= new_label();
          my $end= new_label();
          push(@ifstack, [ $false, $end ]);
	  $lifref= \@ifstack;
        }
      '(' relational_expression ')' statement 
;
iteration_statement:
      WHILE
        { # Generate start and end labels for this loop
          my $start= new_label();
          my $end= new_label();
          push(@loopstack, [ $end, $start ]);
	  $lifref= \@loopstack;
          push(@$Line, ["$start:\t\t\" WHILE start"]);
        }
      '(' relational_expression ')'
      statement
        { push(@$Line, ["jmp $loopstack[-1]->[1]"]);
          push(@$Line, ["$loopstack[-1]->[0]:\t\t\" WHILE end"]);
	  pop(@loopstack);
	}
    | DO
        { # Generate start and end labels for this loop
          my $start= new_label();
          my $end= new_label();
          push(@loopstack, [ $end, $start ]);
	  $lifref= \@loopstack;
          push(@$Line, ["$start:\t\t\" DO start"]);
        }
      statement WHILE '(' relational_expression ')' ';'
        { push(@$Line, ["jmp $loopstack[-1]->[1]"]);
          push(@$Line, ["$loopstack[-1]->[0]:\t\t\" DO end"]);
	  pop(@loopstack);
	}
    | FOR
      '(' assignment_statement ';'
        { # Generate start and end labels for this loop
          my $start= new_label();
          my $end= new_label();
          push(@loopstack, [ $end, $start ]);
	  $lifref= \@loopstack;
          push(@$Line, ["$start:\t\t\" FOR start"]);
        }
      relational_expression ';'
        { # Move all the current lines over to FinalLine
          # and empty $Line for the third statement
          push(@FinalLine, $Line); $Line= [];
        }
      third_for_expression ')' statement
        {
          # Move all the current lines over to FinalLine
          push(@FinalLine, $Line); $Line= [];
          # Pop off the most recent FOR third statement code
          # and save in the FinalLine array
          push(@FinalLine, pop(@Forstack));
          # Now add in the jump at the end of the loop
          push(@$Line, ["jmp $loopstack[-1]->[1]"]);
          push(@$Line, ["$loopstack[-1]->[0]:\t\t\" FOR end"]);
	  pop(@loopstack);
        }
;
third_for_expression:
      assignment_statement
        {
          # Push the third statement code onto the Forstack
          push(@Forstack, $Line); $Line= [];
        }
    | postop_expression
        {
          # Push the third statement code onto the Forstack
          push(@Forstack, $Line); $Line= [];
        }
;

jump_statement:
      GOTO IDENTIFIER.i ';'
  	{ push(@$Line, [ "jmp $i" ]); }
    | CONTINUE ';'
	{ push(@$Line, ["jmp $loopstack[-1]->[1]\t\t\" CONTINUE"]); }
    | BREAK ';'
	{ push(@$Line, ["jmp $loopstack[-1]->[0]\t\t\" BREAK"]); }
    | RETURN ';'
	{ push(@$Line, ["jmp $last_functionid i"]); }
    | RETURN '(' bit_expression.e ')' ';' 
	{ lac($e); push(@$Line, ["jmp $last_functionid i"]); }
;
compound_statement:
      '{' '}'
    | '{' statement_list '}'
    | '{' declaration_list statement_list '}' 
;
postop_statement:
      postop_expression ';' 
;
postop_expression:
      lvalue_expression.l INC_OP
	{ push(@$Line, ['isz', getid($l, 'lac') ]); 
	  push(@$Line, ['nop']); 
	}
    | lvalue_expression.l DEC_OP 
	{ my ($id, $ind)= getid($l, 'lac');
	  push(@$Line, ['-1', '; tad', $id, $ind ]);
	  push(@$Line, ['dac', $id, $ind ]);
	}
;
declaration_list:
      local_declaration
    | local_declaration declaration_list 
;
statement_list:
      statement
    | statement statement_list 
;

%%

sub TERMINAL::info { $_[0]{attr} }
$Parse::Eyapp::Node::INDENT = 2;

sub _Error {
    print("Token " . $_[0]->YYCurval .
          " unexpected on line $linenumber of $Basename.a\n");
    print("Expecting one of: " . join(' ', $_[0]->YYExpect) . "\n");
}

sub _Lexer {
    my($parser)=shift;

    # Loop until we can return a token or there are no lines left
    while (1) {
      # Return a token if possible
      if (@TokenQueue) {
        my $tokptr= shift(@TokenQueue);
        #print("Return token $tokptr->[0] $tokptr->[1]\n");
        return(@{ $tokptr });
      }

      # No tokens, so read a line in. Exit if no lines left
      $_= <$IN> || return('',undef);
      $linenumber++;

      # Pre-processor line
      if (m{^#}) {
	# Pre-processor current line number
        if (m{^#\s*(\d+)}) {
          $linenumber= $1-1;
	}
	# Read in another line
        next;
      }

      # Remove any // comments and leading whitespace
      s{\s*\/\/.*}{}; s{^\s*}{};

      # Break the line up into tokens
      while ($_) {
        if ($incomment) {
          # If we find the end of a multi-line comment, mark out
          if (s{.*\*/\s*}{}) { $incomment = 0; next; }
          # Didn't find one, so get out of this line loop
          # as the whole line is part of the comment.
          last;
        }
        if (s{^/\*\s*}{}) { $incomment = 1; next; }
        if (s{^([A-Za-z_][A-Za-z0-9_]*)\s*}{}) {
          # Push a keyword if found
          if ($Keyword{$1}) { push(@TokenQueue,[$Keyword{$1},$1]); next; }
          push(@TokenQueue,['IDENTIFIER',$1]); next;
        }
        if (s{^0([0-7]+)\s*}{}) {
          push(@TokenQueue,['CONSTANT',oct($1)]); next;
	}
        if (s{^(-?\d+)\s*}{}) {
          push(@TokenQueue,['CONSTANT',$1]); next;
        }
        if (s{^'\\n'\s*}{}) {
          push(@TokenQueue,['CONSTANT',10]); next;
        }
        if (s{^'\\t'\s*}{}) {
          push(@TokenQueue,['CONSTANT',9]); next;
        }
        if (s{^'\\0'\s*}{}) {
          push(@TokenQueue,['CONSTANT',0]); next;
        }
        if (s{^'([^'])'\s*}{}) {
          push(@TokenQueue,['CONSTANT',ord($1)]); next;
        }
	# Two character constant e.g 'ul'
        if (s{^'([^'])([^'])'\s*}{}) {
          push(@TokenQueue,['CONSTANT',ord($1)<<9 | ord($2)]); next;
        }
        if (s{^"([^"]*)"\s*}{}) {
	  # Change literal \n \t \0
	  my $str= $1;
	  $str=~ s/\\n/\n/g; $str=~ s/\\t/\t/g; $str=~ s/\\0/\0/g;
          push(@TokenQueue,['STRINGLITERAL',$str]); next;
        }
        if (s{^(<<)\s*}{}) {
          push(@TokenQueue,['LEFT_OP',$1]); next;
        }
        if (s{^(>>)\s*}{}) {
          push(@TokenQueue,['RIGHT_OP',$1]); next;
        }
        if (s{^(\+\+)\s*}{}) {
          push(@TokenQueue,['INC_OP',$1]); next;
        }
        if (s{^(\&\&)\s*}{}) {
          push(@TokenQueue,['AND_OP',$1]); next;
        }
        if (s{^(\|\|)\s*}{}) {
          push(@TokenQueue,['OR_OP',$1]); next;
        }
        if (s{^(\-\-)\s*}{}) {
          push(@TokenQueue,['DEC_OP',$1]); next;
        }
        if (s{^(\*=)\s*}{}) {
          push(@TokenQueue,['MUL_ASSIGN',$1]); next;
	}
        if (s{^(/=)\s*}{}) {
          push(@TokenQueue,['DIV_ASSIGN',$1]); next;
	}
        if (s{^(%=)\s*}{}) {
          push(@TokenQueue,['MOD_ASSIGN',$1]); next;
	}
        if (s{^(\+=)\s*}{}) {
          push(@TokenQueue,['ADD_ASSIGN',$1]); next;
	}
        if (s{^(-=)\s*}{}) {
          push(@TokenQueue,['SUB_ASSIGN',$1]); next;
	}
        if (s{^(==)\s*}{}) {
          push(@TokenQueue,['EQ_OP',$1]); next;
	}
        if (s{^(!=)\s*}{}) {
          push(@TokenQueue,['NE_OP',$1]); next;
	}
        if (s{^(<=)\s*}{}) {
          push(@TokenQueue,['LE_OP',$1]); next;
	}
        if (s{^(>=)\s*}{}) {
          push(@TokenQueue,['GE_OP',$1]); next;
	}
        if (s{^([-+*/%&|^<>=~.,;:!])\s*}{}) {
          push(@TokenQueue,[$1,$1]); next;
        }
        if (s{^([\(\)\{\}\[\]])\s*}{}) {
          push(@TokenQueue,[$1,$1]); next;
        }
        Die("Unrecognised token on line: $_\n");
      }
    }
}

sub Run {
    my($self,$infile)= @_;

    # Create some globals to hold the filehandles and the basename
    $Basename = $infile;
    $Basename =~ s/\.[a-z]$//;

    # Open the in/out files
    open( $IN, "-|", "cpp -nostdinc -DA_LANG $infile")
    				|| die("Cannot open $infile: $!");
    my $outfile = $Basename . ".s";
    open( $OUT, ">", $outfile ) || die("Cannot write $outfile: $!");
    $incomment  = 0;
    $linenumber = 0;

    new_globalid('.temp','',[0]);
    new_globalid('.ptr1','',[0]);
    new_globalid('.ptr2','',[0]);

    # Parse the class which is in this file
    my $t= $self->YYParse( yylex => \&_Lexer, yyerror => \&_Error);

    write_strliterals();
    push(@FinalLine, $Line);

    # Print out the lines of code
    foreach my $lref (@FinalLine) {
      foreach my $l (@$lref) {
        my $line= join(' ', @$l);
        $line= "\t" . $line if (!($l->[0]=~ m{:}));
        print($OUT "$line\n");
      }
    }

    # Print out constants
    foreach my $c (keys(%Const)) {
      print($OUT "$c: $Const{$c}\n");
    }

    # Print out local variables
    foreach my $fn (keys(%PPosn)) {
      foreach my $id (@{ $PPosn{$fn}}) {
        print($OUT "$fn.$id: 0\n");
      }
    }

    # Close the in/out files
    close($IN);
    close($OUT);
}


### MAIN PROGRAM ###

# Error if no argument
die("Usage: $0 file.h\n") if ( @ARGV != 1 );

# If it's a file, simply parse it
if ( -f $ARGV[0] ) {
    my($parser)=new h;
    $parser->Run($ARGV[0]);
    exit(0);
} else {
  die("Usage: $0 file.h\n");
}

exit(0);
